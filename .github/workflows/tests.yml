import pytest
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import matplotlib
from scatterfit import scatterfit, ScatterFit


# Define a pytest fixture for common test data
@pytest.fixture
def test_data():
    """Create test data for scatterfit tests."""
    np.random.seed(42)
    return pd.DataFrame({
        'x': np.random.normal(0, 1, 100),
        'y': np.random.normal(0, 1, 100),
        'y_binary': np.random.choice([0, 1], 100),
        'group': np.random.choice(['A', 'B'], 100),
        'continuous_control': np.random.normal(0, 1, 100),
        'factor_control': np.random.choice(['X', 'Y', 'Z'], 100)
    })


@pytest.fixture
def complex_test_data():
    """Create more complex test data with multiple predictors."""
    np.random.seed(234)
    n = 500
    data = pd.DataFrame({
        'x1': np.random.normal(size=n),
        'x2': np.random.normal(size=n),
        'x3': np.random.normal(size=n),
        'z': np.random.binomial(n=1, p=.2, size=n),
    })
    data['y'] = data['x1'] * .5 + data['x2'] * data['x2'] * .2 + data['x3'] * .7 + np.random.normal(size=n)
    data["x1_help"] = ((data["x1"] - np.min(data["x1"])) / (np.max(data["x1"]) - np.min(data["x1"]))) * .5
    data['y_dum'] = np.random.binomial(n=1, p=data["x1_help"])
    return data


def check_plot_elements(ax, expected_elements=None):
    """
    Check if all expected elements are present in the plot.

    Parameters:
    -----------
    ax : matplotlib.axes.Axes
        The axes object to check
    expected_elements : dict, optional
        Dictionary of expected elements with counts. Keys can include:
        'scatter', 'line', 'fill', 'text', 'xlabel', 'ylabel', 'legend'

    Returns:
    --------
    dict
        Dictionary of found elements with counts
    """
    if expected_elements is None:
        expected_elements = {}

    # Count various plot elements
    elements = {
        'scatter': 0,
        'line': 0,
        'fill': 0,
        'text': 0,
        'xlabel': ax.get_xlabel() != '',
        'ylabel': ax.get_ylabel() != '',
        'legend': ax.get_legend() is not None,
    }

    # Check for scatter points
    elements['scatter'] = len([c for c in ax.get_children() if isinstance(c, matplotlib.collections.PathCollection)])

    # Check for lines (excluding auxiliary lines like axes and grids)
    all_lines = [c for c in ax.get_children() if isinstance(c, matplotlib.lines.Line2D)]
    elements['line'] = len([line for line in all_lines if len(line.get_xdata()) > 2])  # Substantive lines have data

    # Check for fill_between areas (confidence intervals)
    elements['fill'] = len([c for c in ax.get_children() if isinstance(c, matplotlib.collections.PolyCollection)])

    # Check for text elements (excluding axis labels and titles)
    all_text = [c for c in ax.get_children() if isinstance(c, matplotlib.text.Text)]
    elements['text'] = len([t for t in all_text if t not in [ax.xaxis.label, ax.yaxis.label, ax.title]])

    # Compare with expected elements if provided
    if expected_elements:
        for key, value in expected_elements.items():
            if key in elements:
                assert elements[key] >= value, f"Expected at least {value} {key}(s), found {elements[key]}"

    return elements


# Basic functionality test
def test_basic_scatterfit_runs(test_data):
    """Test that scatterfit runs without errors."""
    fig, ax = plt.subplots()
    result_ax = scatterfit(test_data, 'y', 'x', return_ax=True, ax=ax)

    # Check if it returns an Axes object
    assert result_ax is ax
    plt.close(fig)


# Test for visual elements
def test_visual_elements(test_data):
    """Test that scatterfit produces the expected visual elements."""
    fig, ax = plt.subplots()
    result = scatterfit(test_data, 'y', 'x', return_ax=True, ax=ax, ci=True)

    # Check all expected elements
    elements = check_plot_elements(ax, {
        'scatter': 1,
        'line': 1,
        'fill': 1,
        'xlabel': True,
        'ylabel': True
    })

    plt.close(fig)


# Test binned scatterfit
def test_binned_scatterfit(test_data):
    """Test binned scatter plot functionality."""
    fig, ax = plt.subplots()
    result = scatterfit(test_data, 'y', 'x', return_ax=True, ax=ax, binned=True, n_quantiles=10)

    # Number of scatter points should be around 10 (n_quantiles)
    scatter_elements = [c for c in ax.get_children() if isinstance(c, matplotlib.collections.PathCollection)]
    assert len(scatter_elements) == 1, "Expected exactly one scatter collection"

    # Check for approximately 10 points in the scatter collection
    points = scatter_elements[0].get_offsets()
    assert 8 <= len(points) <= 12, f"Expected around 10 points, got {len(points)}"

    plt.close(fig)


# Test error handling
def test_error_handling():
    """Test that scatterfit handles errors gracefully."""
    # Empty dataframe
    data = pd.DataFrame({'x': [], 'y': []})
    fig, ax = plt.subplots()

    # Should not raise an exception but return the ax
    result = scatterfit(data, 'y', 'x', return_ax=True, ax=ax)
    assert result is ax

    # Nonexistent column
    data = pd.DataFrame({'x': [1, 2, 3], 'y': [4, 5, 6]})
    result = scatterfit(data, 'z', 'x', return_ax=True, ax=ax)
    assert result is ax

    plt.close(fig)


# Test binary variable handling
def test_binary_variable_handling(test_data):
    """Test that binary variables are handled correctly."""
    fig, ax = plt.subplots()
    result = scatterfit(test_data, 'y_binary', 'x', return_ax=True, ax=ax, binned=True)

    # Check if binary data is handled correctly
    y_limits = ax.get_ylim()
    assert y_limits[0] >= -0.1 and y_limits[1] <= 1.1, "Binary y variable should be within [0,1]"

    plt.close(fig)


# Test by_var grouping
def test_by_variable(test_data):
    """Test scatterfit with by_var grouping."""
    fig, ax = plt.subplots()
    result = scatterfit(test_data, 'y', 'x', return_ax=True, ax=ax, by_var='group')

    # Check for multiple scatter collections (one per group)
    elements = check_plot_elements(ax, {
        'scatter': 2,  # One per group
        'line': 2,  # One fit line per group
        'legend': True  # Should have a legend for groups
    })

    plt.close(fig)


# Test regression parameters
def test_regparameters(test_data):
    """Test that regression parameters are displayed correctly."""
    # Add some correlation to the data
    test_data['y_corr'] = test_data['x'] * 0.5 + np.random.normal(0, 1, 100)

    fig, ax = plt.subplots()
    result = scatterfit(test_data, 'y_corr', 'x', return_ax=True, ax=ax, regparameters='coef se r2 nobs')

    # Check for text elements with regression parameters
    elements = check_plot_elements(ax, {
        'scatter': 1,
        'line': 1,
        'text': 1  # At least one text element for parameters
    })

    # Check content of text (should contain coefficient and N=100)
    text_elements = [c for c in ax.get_children() if isinstance(c, matplotlib.text.Text)
                     and c not in [ax.xaxis.label, ax.yaxis.label, ax.title]]

    text_contents = [t.get_text() for t in text_elements]
    combined_text = ' '.join(text_contents)

    assert 'Î²=' in combined_text, "Coefficient not found in text"
    assert 'N=100' in combined_text, "Sample size not found in text"

    plt.close(fig)


# Test x distribution
def test_xdistribution(test_data):
    """Test the x distribution feature."""
    fig, ax = plt.subplots()
    result = scatterfit(test_data, 'y', 'x', return_ax=True, ax=ax, xdistribution='top 0.2')

    # Check that a second axes was created
    assert len(fig.axes) == 2, f"Expected 2 axes (main + kde), got {len(fig.axes)}"

    # Check for line in the KDE plot
    kde_ax = fig.axes[1] if fig.axes[0] is ax else fig.axes[0]
    kde_lines = [c for c in kde_ax.get_children() if isinstance(c, matplotlib.lines.Line2D)]
    assert len(kde_lines) > 0, "No KDE line found"

    plt.close(fig)


# Test controls
def test_controls(test_data):
    """Test that control variables work correctly."""
    fig, ax = plt.subplots()
    result = scatterfit(
        test_data, 'y', 'x',
        return_ax=True, ax=ax,
        controls='continuous_control',
        fcontrols='factor_control'
    )

    # Just check that it runs without error
    assert result is ax
    plt.close(fig)


# Test different fit types
@pytest.mark.parametrize("fit_type", ['linear', 'quadratic', 'cubic', 'lpoly', 'lowess'])
def test_fit_types(test_data, fit_type):
    """Test different fit types."""
    fig, ax = plt.subplots()
    result = scatterfit(test_data, 'y', 'x', return_ax=True, ax=ax, fit=fit_type)

    # Check that appropriate lines were created
    elements = check_plot_elements(ax, {
        'scatter': 1,
        'line': 1
    })

    plt.close(fig)


# Test with different data sizes
@pytest.mark.parametrize("n_points", [10, 50, 200])
def test_different_data_sizes(n_points):
    """Test scatterfit with different data sizes."""
    np.random.seed(42)
    data = pd.DataFrame({
        'x': np.random.normal(0, 1, n_points),
        'y': np.random.normal(0, 1, n_points)
    })

    fig, ax = plt.subplots()
    result = scatterfit(data, 'y', 'x', return_ax=True, ax=ax)

    # Check that it runs without error
    assert result is ax
    plt.close(fig)


# Test class initialization directly
def test_scatterfit_class_init(test_data):
    """Test direct initialization of the ScatterFit class."""
    scatter_fit = ScatterFit(test_data, 'y', 'x')
    assert scatter_fit.y_var == 'y'
    assert scatter_fit.x_var == 'x'
    assert hasattr(scatter_fit, 'df')


# Test for missing data handling
def test_missing_data_handling():
    """Test handling of missing data."""
    # Create data with NaN values
    data = pd.DataFrame({
        'x': [1, 2, 3, 4, 5, np.nan],
        'y': [1, 2, np.nan, 4, 5, 6]
    })

    fig, ax = plt.subplots()
    result = scatterfit(data, 'y', 'x', return_ax=True, ax=ax)

    # Should run without error and drop NaN
    assert result is ax
    plt.close(fig)


# Test the weight_var parameter
def test_weighted_analysis(test_data):
    """Test scatterfit with weighted analysis."""
    # Add a weight column
    test_data['weight'] = np.random.uniform(0.5, 1.5, 100)

    fig, ax = plt.subplots()
    result = scatterfit(test_data, 'y', 'x', return_ax=True, ax=ax, weight_var='weight')

    # Should run without error
    assert result is ax
    plt.close(fig)


# New tests based on the example script
def test_example_plots(complex_test_data):
    """Test all the examples from the example script."""
    data = complex_test_data

    # 1. Simple linear fit
    fig, ax = plt.subplots()
    result = scatterfit(data, y_var='y', x_var='x1', return_ax=True, ax=ax)
    check_plot_elements(ax, {'scatter': 1, 'line': 1, 'xlabel': True, 'ylabel': True})
    plt.close(fig)

    # 2. Change the fit line
    fig, ax = plt.subplots()
    result = scatterfit(data, y_var='y', x_var='x2', fit="lpoly", return_ax=True, ax=ax)
    check_plot_elements(ax, {'scatter': 1, 'line': 1, 'xlabel': True, 'ylabel': True})
    plt.close(fig)

    # 3. With data binning
    fig, ax = plt.subplots()
    result = scatterfit(data, y_var='y', x_var='x1', binned=True, return_ax=True, ax=ax)
    check_plot_elements(ax, {'scatter': 1, 'line': 1, 'xlabel': True, 'ylabel': True})
    plt.close(fig)

    # 4. Binary y variable
    fig, ax = plt.subplots()
    result = scatterfit(data, y_var='y_dum', x_var='x1', binned=True, return_ax=True, ax=ax)
    y_limits = ax.get_ylim()
    assert y_limits[0] >= -0.1 and y_limits[1] <= 1.1, "Binary y variable should be within [0,1]"
    plt.close(fig)

    # 5. Uniform bins
    fig, ax = plt.subplots()
    result = scatterfit(data, y_var='y', x_var='x1', binned=True, uni_bins=40, return_ax=True, ax=ax)
    scatter_elements = [c for c in ax.get_children() if isinstance(c, matplotlib.collections.PathCollection)]
    if scatter_elements:
        points = scatter_elements[0].get_offsets()
        assert len(points) <= 45, f"Expected around 40 points, got {len(points)}"
    plt.close(fig)

    # 6. With weighted markers
    fig, ax = plt.subplots()
    result = scatterfit(data, y_var='y', x_var='x1', binned=True, uni_bins=40, mweighted=True, return_ax=True, ax=ax)
    check_plot_elements(ax, {'scatter': 1, 'line': 1})
    plt.close(fig)

    # 7. Separate fits for by-dimension
    fig, ax = plt.subplots()
    result = scatterfit(data, y_var='y', x_var='x1', by_var="z", return_ax=True, ax=ax)
    check_plot_elements(ax, {'scatter': 2, 'line': 2, 'legend': True})
    plt.close(fig)

    # 8. Residualized data / control variables
    fig, ax = plt.subplots()
    result = scatterfit(data, y_var='y', x_var='x1', controls=["x2"], fcontrols=["z"], return_ax=True, ax=ax)
    check_plot_elements(ax, {'scatter': 1, 'line': 1})
    plt.close(fig)

    # 9. Regression parameters in plot
    fig, ax = plt.subplots()
    result = scatterfit(data, y_var='y', x_var='x1', regparameters=["coef", "sig", "nobs", "pval"], return_ax=True,
                        ax=ax)
    check_plot_elements(ax, {'scatter': 1, 'line': 1, 'text': 1})
    plt.close(fig)

    # 10. Distribution of x variable
    fig, ax = plt.subplots()
    result = scatterfit(data, y_var='y', x_var='x1', xdistribution="auto", return_ax=True, ax=ax)
    assert len(fig.axes) > 1, "Expected multiple axes for x distribution"
    plt.close(fig)


def test_multiple_subplots(complex_test_data):
    """Test creating multiple subplots."""
    data = complex_test_data

    # Create a figure with multiple subplots
    fig, axes = plt.subplots(nrows=1, ncols=3, figsize=(12, 5))

    for i, xvar in enumerate(["x1", "x2", "x3"]):
        result = scatterfit(data=data, y_var='y', x_var=xvar, ax=axes[i])
        check_plot_elements(axes[i], {'scatter': 1, 'line': 1, 'xlabel': True, 'ylabel': True})

    plt.close(fig)


# Additional tests for edge cases and special features

def test_jitter_option(test_data):
    """Test the jitter option for better visualization of dense data."""
    fig, ax = plt.subplots()
    result = scatterfit(test_data, 'y', 'x', return_ax=True, ax=ax, jitter=0.1)

    # Should run without error
    assert result is ax
    plt.close(fig)


def test_standardize_option(test_data):
    """Test the standardize option for comparing variables on different scales."""
    fig, ax = plt.subplots()
    result = scatterfit(test_data, 'y', 'x', return_ax=True, ax=ax, standardize=True)

    # Should run without error and apply standardization
    assert result is ax
    plt.close(fig)


def test_mlabel_option(test_data):
    """Test the mlabel option for labeling points."""
    test_data['point_label'] = [f"P{i}" for i in range(len(test_data))]

    fig, ax = plt.subplots()
    result = scatterfit(test_data, 'y', 'x', return_ax=True, ax=ax, mlabel='point_label')

    # Check text elements (should be many with point labels)
    text_elements = [c for c in ax.get_children() if isinstance(c, matplotlib.text.Text)
                     and c not in [ax.xaxis.label, ax.yaxis.label, ax.title]]
    assert len(text_elements) > 0, "No point labels found"

    plt.close(fig)


def test_discrete_binning(test_data):
    """Test discrete binning option."""
    # Create data with discrete x values
    data = pd.DataFrame({
        'x_discrete': np.random.choice(list(range(10)), 100),
        'y': np.random.normal(0, 1, 100)
    })

    fig, ax = plt.subplots()
    result = scatterfit(data, 'y', 'x_discrete', return_ax=True, ax=ax, binned=True, discrete=True)

    # Check if we have approximately the right number of points (should be <= 10)
    scatter_elements = [c for c in ax.get_children() if isinstance(c, matplotlib.collections.PathCollection)]
    if scatter_elements:
        points = scatter_elements[0].get_offsets()
        assert len(points) <= 10, f"Expected <= 10 points for discrete binning, got {len(points)}"

    plt.close(fig)


def test_axis_titles(test_data):
    """Test custom axis titles."""
    fig, ax = plt.subplots()
    result = scatterfit(test_data, 'y', 'x', return_ax=True, ax=ax,
                        xtitle="Custom X Title", ytitle="Custom Y Title")

    assert ax.get_xlabel() == "Custom X Title", "Custom X title not applied"
    assert ax.get_ylabel() == "Custom Y Title", "Custom Y title not applied"

    plt.close(fig)


def test_interaction_analysis(complex_test_data):
    """Test interaction analysis with bymethod=interact."""
    data = complex_test_data

    fig, ax = plt.subplots()
    result = scatterfit(data, 'y', 'x1', by_var='z', bymethod='interact',
                        regparameters=["coef", "int", "pval", "sig"],
                        return_ax=True, ax=ax)

    # Verify that it runs and creates text elements with interaction parameters
    text_elements = [c for c in ax.get_children() if isinstance(c, matplotlib.text.Text)
                     and c not in [ax.xaxis.label, ax.yaxis.label, ax.title]]
    assert len(text_elements) > 0, "No interaction parameter text found"

    plt.close(fig)


def test_color_customization(test_data):
    """Test color customization options."""
    fig, ax = plt.subplots()
    # Test with a standard matplotlib colormap
    result = scatterfit(test_data, 'y', 'x', by_var='group',
                        colorscheme='viridis',
                        return_ax=True, ax=ax)

    # Should run without error
    assert result is ax
    plt.close(fig)


def test_empty_group_handling(test_data):
    """Test handling of empty groups in by_var."""
    # Create a dataset with an empty group
    test_data['sparse_group'] = 'A'
    test_data.loc[0:5, 'sparse_group'] = 'B'  # Only a few in group B

    # Filter to create an empty group
    data_subset = test_data[test_data['x'] > 0]  # This might eliminate group B entirely

    fig, ax = plt.subplots()
    # Should handle gracefully even if one group becomes empty
    result = scatterfit(data_subset, 'y', 'x', by_var='sparse_group',
                        return_ax=True, ax=ax)

    # Should run without error
    assert result is ax
    plt.close(fig)


# If you want to run these tests directly from this file
if __name__ == "__main__":
    pytest.main(['-v', __file__])
